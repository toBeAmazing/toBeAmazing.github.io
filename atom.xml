<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JollyFly&#39;s Blog</title>
  <subtitle>勿在浮沙筑高台</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-08T06:06:40.362Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JollyFly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中Volatile关键字详解</title>
    <link href="http://yoursite.com/2017/07/08/volatile/"/>
    <id>http://yoursite.com/2017/07/08/volatile/</id>
    <published>2017-07-08T07:50:28.000Z</published>
    <updated>2017-07-08T06:06:40.362Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>volatile是java中的关键字，在涉及到并发编程时会用到，特地对其特点进行学习与总结，<br>以更好的理解其应用场景以及其中的原理。</p>
</blockquote>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ol>
<li>可见性</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;volatile是java中的关键字，在涉及到并发编程时会用到，特地对其特点进行学习与总结，&lt;br&gt;以更好的理解其应用场景以及其中的原理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>TCP通信的探索</title>
    <link href="http://yoursite.com/2017/07/08/tcp/"/>
    <id>http://yoursite.com/2017/07/08/tcp/</id>
    <published>2017-07-08T05:50:28.000Z</published>
    <updated>2017-07-08T05:03:11.670Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>使用java进行TCP通信已经比较熟练了，但是对其中的过程及原理还不是很了解。本次使用网络<br>抓包分析工具Wireshark对TCP通信的过程进行探索，并记录。</p>
</blockquote>
<p>TCP(Transmission Control Protocol)即传输控制协议</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用java进行TCP通信已经比较熟练了，但是对其中的过程及原理还不是很了解。本次使用网络&lt;br&gt;抓包分析工具Wireshark对TCP通信的过程进行探索，并记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP(Transmission Con
    
    </summary>
    
      <category term="网络基础" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="tcp通信" scheme="http://yoursite.com/tags/tcp%E9%80%9A%E4%BF%A1/"/>
    
      <category term="传输控制协议" scheme="http://yoursite.com/tags/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>linux下安装rabbitMQ</title>
    <link href="http://yoursite.com/2017/07/08/rabbitmq-install/"/>
    <id>http://yoursite.com/2017/07/08/rabbitmq-install/</id>
    <published>2017-07-08T03:50:48.000Z</published>
    <updated>2017-07-08T04:56:54.236Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>此篇博客主要记录rabbitMQ在linux系统上的安装过程，使用与CentOS、Redhat。</p>
</blockquote>
<h2 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h2><p>RabbitMQ由Erlang实现，所以安装Erlang必不可少</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/</div><div class="line">mkdir rabbitmq</div><div class="line"><span class="built_in">cd</span> rabbitmq</div><div class="line">wget http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm</div><div class="line">rpm -Uvh erlang-solutions-1.0-1.noarch.rpm</div><div class="line">rpm --import http://packages.erlang-solutions.com/rpm/erlang_solutions.asc</div><div class="line">sudo yum install erlang</div></pre></td></tr></table></figure>
<blockquote>
<p><img src="/img/erlang.png" alt="安装Erlang"></p>
</blockquote>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#上传rpm安装包到/usr/local/src/rabbitmq/   可使用rz命令上传</span></div><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/rabbitmq</div><div class="line">rz -y</div><div class="line"><span class="comment">#上传完成后安装</span></div><div class="line">rpm -ivh rabbitmq-server-3.4.1-1.noarch.rpm</div></pre></td></tr></table></figure>
<h3 id="服务的启动与停止"><a href="#服务的启动与停止" class="headerlink" title="服务的启动与停止"></a>服务的启动与停止</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">service rabbitmq-server start</div><div class="line">service rabbitmq-server stop</div><div class="line">service rabbitmq-server restart</div></pre></td></tr></table></figure>
<h3 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig rabbitmq-server on</div></pre></td></tr></table></figure>
<h3 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/rabbitmq</div><div class="line">cp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example /etc/rabbitmq/</div><div class="line">mv rabbitmq.config.example rabbitmq.config</div></pre></td></tr></table></figure>
<h3 id="开启用户远程访问"><a href="#开启用户远程访问" class="headerlink" title="开启用户远程访问"></a>开启用户远程访问</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/rabbitmq/rabbitmq.config</div></pre></td></tr></table></figure>
<p><img src="/img/rabbitmq1.png" alt="用户远程访问"></p>
<h3 id="开启web界面管理工具"><a href="#开启web界面管理工具" class="headerlink" title="开启web界面管理工具"></a>开启web界面管理工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</div><div class="line">service rabbitmq-server restart</div></pre></td></tr></table></figure>
<h3 id="防火墙开放15672端口"><a href="#防火墙开放15672端口" class="headerlink" title="防火墙开放15672端口"></a>防火墙开放15672端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT</div><div class="line">/etc/rc.d/init.d/iptables save</div></pre></td></tr></table></figure>
<h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><blockquote>
<p>安装并配置完成后，需要登录web界面管理工具添加用户</p>
</blockquote>
<p><img src="/img/rabbitmq2.png" alt="web界面"></p>
<h3 id="用户角色"><a href="#用户角色" class="headerlink" title="用户角色"></a>用户角色</h3><ol>
<li>超级管理员（adminisitrator）<br>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</li>
<li>监控者(monitoring)<br>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</li>
<li>策略制定者(policymaker)<br>可登陆管理控制台, 同时可以对polic进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</li>
<li>普通管理者(management)<br>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</li>
<li>其他<br>无法登陆管理控制台，通常就是普通的生产者和消费者。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此篇博客主要记录rabbitMQ在linux系统上的安装过程，使用与CentOS、Redhat。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装Erlang&quot;&gt;&lt;a href=&quot;#安装Erlang&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="软件安装" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="mq" scheme="http://yoursite.com/tags/mq/"/>
    
  </entry>
  
  <entry>
    <title>redis学习与总结</title>
    <link href="http://yoursite.com/2017/07/07/redis/"/>
    <id>http://yoursite.com/2017/07/07/redis/</id>
    <published>2017-07-07T08:50:48.000Z</published>
    <updated>2017-07-07T08:55:23.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis的基本数据类型"><a href="#Redis的基本数据类型" class="headerlink" title="Redis的基本数据类型"></a>Redis的基本数据类型</h3><blockquote>
<p>redis中目前支持五种数据类型：</p>
<ol>
<li>String </li>
<li>List </li>
<li>Hash </li>
<li>Set</li>
<li>Sorted Set<h4 id="1-1-String"><a href="#1-1-String" class="headerlink" title="1.1.String"></a>1.1.String</h4><h5 id="1-1-1-结构说明"><a href="#1-1-1-结构说明" class="headerlink" title="1.1.1.结构说明"></a>1.1.1.结构说明</h5>String是简单的key-value键值对。<h5 id="1-1-2基本命令"><a href="#1-1-2基本命令" class="headerlink" title="1.1.2基本命令"></a>1.1.2基本命令</h5>赋值与取值：<br><br>SET key value<br>GET key<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; set content hello</div><div class="line">OK</div><div class="line">redis 127.0.0.1:6379&gt; get content</div><div class="line">&quot;hello&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h5 id="1-1-3-Jedis中操作String"><a href="#1-1-3-Jedis中操作String" class="headerlink" title="1.1.3.Jedis中操作String"></a>1.1.3.Jedis中操作String</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</div><div class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</div><div class="line">        String content = jedis.get(<span class="string">"content"</span>);</div><div class="line">        System.out.println(content);</div><div class="line">        jedis.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-2-List"><a href="#1-2-List" class="headerlink" title="1.2.List"></a>1.2.List</h4><h5 id="1-2-1-结构说明"><a href="#1-2-1-结构说明" class="headerlink" title="1.2.1.结构说明"></a>1.2.1.结构说明</h5><blockquote>
<p>redis中的List实现为一个双向链表，类似于java中的LinkedList。支持反向查找和遍历。</p>
<h5 id="1-2-2基本命令"><a href="#1-2-2基本命令" class="headerlink" title="1.2.2基本命令"></a>1.2.2基本命令</h5><ul>
<li>BLPOP<br>BLPOP key1 [key2] timeout 取出并获取列表中的第一个元素，或阻塞，直到有可用</li>
<li>BRPOP<br>BRPOP key1 [key2] timeout 取出并获取列表中的最后一个元素，或阻塞，直到有可用</li>
<li>LINDEX<br>LINDEX key index 根据一个列表的索引，获取对应位置的元素</li>
<li>LINSERT<br>LINSERT key BEFORE|AFTER pivot value 在列表中的指定元素之后或之前插入一个元素，若<br>  有重复元素仅对第一个生效。</li>
<li>LLEN<br>LLEN key 获取列表的长度</li>
<li>LRANGE<br>LRANGE key start stop 从一个列表中获取各种元素</li>
<li>LREM<br>LREM key count value 从列表中删除第count个指定value。如果count是0，所有的值为value<br>  的元素都会被删除。如果count是一个负数，则从列表的尾部到头部删除。</li>
<li>LSET<br>LSET key index value 将列表中指定索引的值更新为value。<h5 id="1-2-3基本命令使用"><a href="#1-2-3基本命令使用" class="headerlink" title="1.2.3基本命令使用"></a>1.2.3基本命令使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; lpush list1 redis</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; lpush list1 hello</div><div class="line">(integer) 2</div><div class="line">redis 127.0.0.1:6379&gt; rpush list1 world</div><div class="line">(integer) 3</div><div class="line">redis 127.0.0.1:6379&gt; llen list1</div><div class="line">(integer) 3</div><div class="line">redis 127.0.0.1:6379&gt; lrange list1 0 3</div><div class="line">1) &quot;hello&quot;</div><div class="line">2) &quot;redis&quot;</div><div class="line">3) &quot;world&quot;</div><div class="line">redis 127.0.0.1:6379&gt; lpop list1</div><div class="line">&quot;hello&quot;</div><div class="line">redis 127.0.0.1:6379&gt; rpop list1</div><div class="line">&quot;world&quot;</div><div class="line">redis 127.0.0.1:6379&gt; lrange list1 0 3</div><div class="line">1) &quot;redis&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h5 id="1-2-4jedis中操作List"><a href="#1-2-4jedis中操作List" class="headerlink" title="1.2.4jedis中操作List"></a>1.2.4jedis中操作List</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">String books[] = &#123;&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;,&quot;eee&quot;&#125;;</div><div class="line">jedis.lpush(&quot;books&quot;,books);</div><div class="line">System.out.println(jedis.llen(&quot;books&quot;));</div><div class="line">jedis.lrange(&quot;books&quot;,0,100).forEach(e-&gt;&#123;</div><div class="line">    System.out.println(e);</div><div class="line">&#125;);</div><div class="line">System.out.println(&quot;LINDEX:&quot;+jedis.lindex(&quot;books&quot;,3));</div><div class="line">jedis.linsert(&quot;books&quot;, BinaryClient.LIST_POSITION.AFTER,&quot;aaa&quot;,&quot;xxx&quot;);</div><div class="line">System.out.println(&quot;-----------&quot;);</div><div class="line">jedis.lrange(&quot;books&quot;,0,100).forEach(e-&gt;&#123;</div><div class="line">    System.out.println(e);</div><div class="line">&#125;);</div><div class="line">System.out.println(&quot;-----------&quot;);</div><div class="line"></div><div class="line">jedis.lrem(&quot;books&quot;,0,&quot;ccc&quot;);</div><div class="line"></div><div class="line">jedis.lset(&quot;books&quot;,0,&quot;yy&quot;);</div><div class="line">jedis.lrange(&quot;books&quot;,0,100).forEach(e-&gt;&#123;</div><div class="line">    System.out.println(e);</div><div class="line">&#125;);</div><div class="line">jedis.close();</div></pre></td></tr></table></figure>
<h4 id="1-3-Hash"><a href="#1-3-Hash" class="headerlink" title="1.3.Hash"></a>1.3.Hash</h4><h5 id="1-3-1结构说明"><a href="#1-3-1结构说明" class="headerlink" title="1.3.1结构说明"></a>1.3.1结构说明</h5><blockquote>
<p>散列类型存储了字段和字段值的映射，但字段值只能是字符串，不支持其他类型，也就是说，散列类型不能<br>嵌套其他的数据类型。</p>
<h5 id="1-3-2基本命令使用"><a href="#1-3-2基本命令使用" class="headerlink" title="1.3.2基本命令使用"></a>1.3.2基本命令使用</h5><ul>
<li>HSET<br>HSET key field value 设置对象指定字段的值</li>
<li>HGET<br>HGET key field 获取对象中该field属性域的值</li>
<li>HMSET<br>HMSET key field value [field value …] 同时设置对象中一个或多个字段的值</li>
<li>HMGET<br>HMGET key field[field…] 获取对象的一个或多个指定字段的值</li>
<li>HGETALL<br>HGETALL key 获取对象的所有属性域和值</li>
<li>HDEL<br>HDEL key field[field…] 删除对象的一个或几个属性域，不存在的属性将被忽略<h5 id="1-3-3使用示例"><a href="#1-3-3使用示例" class="headerlink" title="1.3.3使用示例"></a>1.3.3使用示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; hset person name jack</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; hset person age 20</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; hset person sex famale</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; hgetall person</div><div class="line">1) &quot;name&quot;</div><div class="line">2) &quot;jack&quot;</div><div class="line">3) &quot;age&quot;</div><div class="line">4) &quot;20&quot;</div><div class="line">5) &quot;sex&quot;</div><div class="line">6) &quot;famale&quot;</div><div class="line">127.0.0.1:6379&gt; hkeys person</div><div class="line">1) &quot;name&quot;</div><div class="line">2) &quot;age&quot;</div><div class="line">3) &quot;sex&quot;</div><div class="line">127.0.0.1:6379&gt; hvals person</div><div class="line">1) &quot;jack&quot;</div><div class="line">2) &quot;20&quot;</div><div class="line">3) &quot;famale&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h5 id="1-3-4-Jedis中操作Hash结构"><a href="#1-3-4-Jedis中操作Hash结构" class="headerlink" title="1.3.4.Jedis中操作Hash结构"></a>1.3.4.Jedis中操作Hash结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Map&lt;String,String&gt; dataMap = new HashMap&lt;String,String&gt;();</div><div class="line">dataMap.put(&quot;id&quot;,&quot;1001&quot;);</div><div class="line">dataMap.put(&quot;name&quot;,&quot;Lisa&quot;);</div><div class="line">dataMap.put(&quot;age&quot;,&quot;23&quot;);</div><div class="line">jedis.hmset(&quot;user_1001&quot;,dataMap);</div><div class="line">System.out.println(jedis.hget(&quot;user_1001&quot;,&quot;age&quot;));</div><div class="line">dataMap = jedis.hgetAll(&quot;user_1001&quot;);</div><div class="line">System.out.println(dataMap);</div></pre></td></tr></table></figure>
<h3 id="Redis配置文件"><a href="#Redis配置文件" class="headerlink" title="Redis配置文件"></a>Redis配置文件</h3><blockquote>
<p>redis默认配置文件为redis.conf,常用配置如下：</p>
<ol>
<li>port  服务端口号</li>
<li>bind  绑定ip，其他的ip不能访问（多个ip用空格隔开）</li>
<li>databases 数据库数量，默认为16个</li>
<li>daemonize 设置为守护进程</li>
<li>maxmemory 最大内存大小</li>
</ol>
</blockquote>
<h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><blockquote>
<p>Redis支持两种方式的持久化，一种是RDB，一种是AOF。可以单独使用其中一种或者两种结合使用。</p>
<h4 id="3-1-RDB持久化"><a href="#3-1-RDB持久化" class="headerlink" title="3.1.RDB持久化"></a>3.1.RDB持久化</h4><p>RDB是用过快照完成的，当符合一定条件时，Redis会自动将内存中的所有数据进行快照并且存储到硬盘上。<br>进行快照的条件在配置文件中指定。RDB是Redis默认的持久化方式。<br><br>在配置文件中预置了3个RDB持久化的条件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">save 900 1 #15分钟内有至少一个键被更改则进行快照</div><div class="line">save 300 10 #5分钟内至少有10个键被更改则进行快照</div><div class="line">save 60 100000 #1分钟内至少有10000个键被更改则进行快照</div></pre></td></tr></table></figure></p>
<p>以上条件之间是或的关系。默认的rdb文件路径是在当前目录，文件名是：dump.rdb，可以在配置文件<br>中修改路径和文件名，分别是dir和dbfilename。注释掉所有的RDB触发条件即可关闭RDB持久化。</p>
<h4 id="3-2-AOF持久化"><a href="#3-2-AOF持久化" class="headerlink" title="3.2.AOF持久化"></a>3.2.AOF持久化</h4><p>Redis的AOF持久化的原理是将发送到Redis服务端的每一条命令都记录下来，并且保存到硬盘中的AOF文件。<br>AOF文件的位置和RDB文件的位置相同，都是通过dir参数设置。默认的文件名是appendonly.aof，可以通过<br>appendfilename参数修改。AOF持久化默认是不开启的，在配置文件中开启：<br><code>appendonly  yes</code><br></p>
<h3 id="4-Redis集群"><a href="#4-Redis集群" class="headerlink" title="4.Redis集群"></a>4.Redis集群</h3><p>在Redis3.0及以上版本一大特性就是集群。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Redis的基本数据类型&quot;&gt;&lt;a href=&quot;#Redis的基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;Redis的基本数据类型&quot;&gt;&lt;/a&gt;Redis的基本数据类型&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;redis中目前支持五种数据类型：
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="nosql" scheme="http://yoursite.com/tags/nosql/"/>
    
  </entry>
  
  <entry>
    <title>NIO学习与总结</title>
    <link href="http://yoursite.com/2017/07/07/nio/"/>
    <id>http://yoursite.com/2017/07/07/nio/</id>
    <published>2017-07-07T08:50:48.000Z</published>
    <updated>2017-07-07T09:02:50.594Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nio即non-blocking IO翻译过来就是非阻塞式IO</p>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Channel意思是通道，在NIO中，数据从通道读入到缓冲区，<br>再从缓冲区获取。常见的Channel类型有：FileChannel,DatagramChannel,SocketChannel,<br>ServerSocketChannel。</p>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NIO里面关键的Buffer实现：ByteBuffer，CharBuffer，<br>DoubleBuffer，FloatBuffer，IntBuffer，LongBuffer，ShortBuffer<br>这些Buffer覆盖了你能通过IO发送的基本数据类型：byte，short，int，long，float，<br>double和char。<br><br>Buffer的初始状态为read状态，如果需要写入数据  需要先调用flip()方法<br></p>
<ul>
<li>capacity:<br><br>作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个<br>byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）<br>才能继续写数据往里写数据。</li>
<li>position<br><br>当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、<br>long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。<br>position最大可为capacity – 1.当读取数据时，也是从某个特定位置读。当将Buffer<br>从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，<br>position向前移动到下一个可读的位置。</li>
<li>limit<br><br>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于<br>Buffer的capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，<br>当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到<br>之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</li>
<li>scatter/gather<br><br>分散（scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，<br>Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。<br><br>聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，<br>因此，Channel将多个Buffer中的数据“聚集（gather）”后发送到Channel。<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4>使用Selector可以用一个线程来管理多个通道。<br><br>Selector的创建:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//使用open()方法创建一个Selector对象</div><div class="line">Selector selector = Selector.open();</div><div class="line">//与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel&lt;br&gt;</div><div class="line">//与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</div><div class="line">serverSocketChannel.configureBlocking(false);</div><div class="line">SelectionKey key = serverSocketChannel.register(selector,Selectionkey.OP_READ);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上代码中，register()方法的第二个参数，<br>意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四中不同类型的事件：</p>
<ol>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通道触发了一个事件意思是该事件已经就绪。<br>所以，某个channel成功连接到另一个服务器称为”连接就绪”。一个server socket channel准备好接<br>收新进入的连接称为”接收就绪”。一个有数据可读的通道可以说是”读就绪”。等待写数据的通道可以说是<br>“写就绪”。这四种事件用SelectionKey的四个常量来表示：</li>
<li>SelectionKey.OP_CONNECT &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   连接就绪</li>
<li>SelectionKey.OP_ACCEPT     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   接收就绪</li>
<li>SelectionKey.OP_READ    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     读就绪</li>
<li>SelectionKey.OP_WRITE    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     写就绪<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你对不止一种事件感兴趣，那么可以用<br>“位或”操作符将常量连接起来，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>selector中select()方法:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int select(); //会阻塞</div><div class="line">int select(long timeout); //阻塞timeout毫秒</div><div class="line">int selectNow();//不会阻塞，立即返回</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select()方法返回的int值表示有多少通道已经就绪。<br>   亦即，自上次调用select()方法后有多少通道变成就绪状态。<br>   如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就<br>   绪了，它会再次返回1.如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但是在每次select()<br>   方法调用之间，只有一个通道就绪了。调用过select()方法之后。如果返回值表明有一个或更多通道就绪了，就可以<br>   通过调用selector的selectKeys()方法，访问”已选择健集”中的就绪通道，如下所示：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"> Set selectedKeys = selector.selectedKeys();</div><div class="line"> //可以遍历这个已选择的键集合来访问就绪的通道。</div><div class="line"> Set selectKeys = selector.selectedKeys();</div><div class="line"> Iterator keyIterator = selectedKey.iterator();</div><div class="line"> while(keyIterator.hasNext())&#123;</div><div class="line">     SelectionKey key = keyIterator.next();</div><div class="line">     if(key.isAcceptable)&#123;</div><div class="line">         // 接收就绪</div><div class="line">     &#125; </div><div class="line">     if(key.isConnectable())&#123;</div><div class="line">         // 连接就绪</div><div class="line">     &#125;</div><div class="line">     if(key.isReadable())&#123;</div><div class="line">         // 读就绪</div><div class="line">     &#125;</div><div class="line">     if(key.isWritable())&#123;</div><div class="line">         // 写就绪</div><div class="line">     &#125;</div><div class="line">     keyIterator.remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意每次迭代末尾的keyIterator.remove()调用。<br>    Selector不会自己从已选择键集中移除SelectionKey实例。<br>   必须在处理完通道时自己移除。<br>   下次该通道变成就绪时，Selector会再次将其放入已选择健集中。<br>   SelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。<br><br>       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wakeUp():<br><br>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某个线程调用select()方法后阻塞了，即使没有通道已经就绪，<br>   也有办法让其从select()方法返回。<br>   只要让其它线程在第一个线程调用的select()方法的那个对象上调用selector.wakeup()方法即可。<br>   阻塞在select()方法上的线程会立马返回。<br>   如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即”醒来(wake up)”。<br>   <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>   用完Selector之后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p>
<h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey<br></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当向Selector注册Channel时，register()<br>  方法会返回一个SelectionKey对象。这个对象包含了一下内容：</p>
<ol>
<li>interest集合<br><br>interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int interestSet = selectionKey.interestOps();</div><div class="line">boolean isInterestedAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT;</div><div class="line">boolean isInterestedInConnect = (interestSet &amp; SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT;</div><div class="line">boolean isInterestedInRead = (insterestSet &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ;</div><div class="line">boolean isInterestedInWrite = (insterestSet &amp; SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>通过”位与”操作interest集合和给定的SelectionKey常量，可以确定某个事件是否在interest集合中。</p>
<ol>
<li>ready集合<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ready集合是通道已经准备就绪的操作的集合。<br>你可以这样访问ready集合:<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int readySet = selectionKey.readyOps();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以用像检测interest集合那样的方法，<br>        来检测Channel中什么事件或操作已经就绪。但是，也可以使用一下四个方法，它们都会返回一个布尔类型：<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">selectionKey.isAcceptable();</div><div class="line">selectionKey.isConnectable();</div><div class="line">selectionKey.isReadable();</div><div class="line">sekectionKey.isWritable();</div></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li><p>Channel和Selector：</p>
<blockquote>
<p>可通过一下方式获取Channel和Selector对象</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Channel channel = selectionKey.channel();</div><div class="line">Selector selector = selectionKey.selector();</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>附加对象</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将一个对像或者更多信息附着到<br>SelectionKey上，这样就能方便的识别某个给定的通道。附加方法如下：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">selectionKey.attach(theObject);</div><div class="line">Object attachedObj = selectionKey.attachment();</div></pre></td></tr></table></figure></blockquote>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;nio即non-b
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java基础" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="nio" scheme="http://yoursite.com/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习与总结</title>
    <link href="http://yoursite.com/2017/07/07/mysql/"/>
    <id>http://yoursite.com/2017/07/07/mysql/</id>
    <published>2017-07-07T07:23:48.000Z</published>
    <updated>2017-07-07T08:47:10.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数据库范式"><a href="#1-数据库范式" class="headerlink" title="1.数据库范式"></a>1.数据库范式</h3><ol>
<li>第一范式（1NF）：<blockquote>
<p>第一范式强调的是列的原子性，即列不能够再分成其他几列。</p>
</blockquote>
</li>
<li>第二范式（2NF）：<blockquote>
<p>首先要满足第一范式的要求，另外包含两部分内容，一是表必须有主键；<br>二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。<br>例如一个订单明细表（OrderId，ProductId，Quantity，UnitPrice）<br><br>在这张表中，单单通过一个OrderId是不足以成为主键的，主键应该是（OrderId,ProductId）<br>可以将表拆分为（OrderId,ProductId,Quantity）和（ProductId,UnitPrice）</p>
</blockquote>
</li>
<li>第三范式（3NF）：<blockquote>
<p>首先是要满足2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列B依赖于主键的情况。<br><br>例如一个订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID）。<br>其中 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。<br>通过拆分【Order】为【Order】（OrderID，OrderDate，CustomerID）和【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。</p>
</blockquote>
</li>
</ol>
<h3 id="2-索引基础"><a href="#2-索引基础" class="headerlink" title="2.索引基础"></a>2.索引基础</h3><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><blockquote>
<p>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，<br>取而代之的是从索引的根节点(图示并未画出)开始进行搜索。根节点的槽中存放了指向子节点的指针，<br>存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层<br>子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么<br>该记录不存在。<br><br>索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。<br>例：假设有如下数据表：<br>CREATE TABLE People(<br>    last_name  varchar(50)   not null,<br>    first_name varchar(50)   not null,<br>    dob        date             not null,<br>    gender       enum(‘m’,’f’) not null,<br>    key(last_name, first_name, dob)<br>);</p>
</blockquote>
<p>对于表中的每一行数据，索引中包含了last_name,first_name和dob列的值。<br>可以使用B-Tree索引的查询类型。B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找<br>只适用于根据最左前缀的查找。上面所述的索引对如下类型的查询有效。</p>
<ol>
<li>全值匹配<br><br>全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引可用于查找姓名为 Cuba Allen、<br>出生于1960-01-01的人。</li>
<li>匹配最左前缀(last_name)<br><br>前面提到的索引可用于查找所有姓为Allen的人，即只使用索引的第一列。</li>
<li>匹配列前缀<br><br>也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开<br>头的姓的人。<br>这里也只使用了索引的第一列。</li>
<li>匹配范围值<br><br>例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人，这里也只使<br>用了索引的第一列。</li>
<li>精确匹配某一列并范围匹配另外一列<br><br>前面提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头的人。</li>
<li>只访问索引的查询<br><br>B-Tree通常可以支持”只访问索引的查询”，即查询只需要访问索引，<br>而无须访问数据行。</li>
</ol>
<h5 id="B-Tree索引的限制："><a href="#B-Tree索引的限制：" class="headerlink" title="B-Tree索引的限制："></a>B-Tree索引的限制：</h5><ol>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。</li>
<li>不能跳过索引中的列。</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li>
</ol>
<h5 id="典型优化："><a href="#典型优化：" class="headerlink" title="典型优化："></a>典型优化：</h5><blockquote>
<p>使用B-Tree存储URL，因为URL一般比较长，因此数据量大的时候，查询会变得缓<br> 慢。若删除原来URL列上的索引，而新增一个被索引的url_crc列，使用CRC32做<br> 哈希，就可以使用下面的方式查询：</p>
</blockquote>
 <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> #原查询语句：</div><div class="line">   SELECT id FROM url WHERE url='http://www.mysql.com';</div><div class="line">#修改后的语句：</div><div class="line">   SELECT id FROM url WHERE url='http://www.mysql.com'</div><div class="line">                 AND url_crc=CRC32('http://www.mysql.com');</div></pre></td></tr></table></figure>
<blockquote>
<p>这样做的性能会非常高，因为MySQL优化器会使用这个选择性很高而体积很小的基于url_crc列的索引<br>来完成查找。即使有多个记录有相同的索引值，查找仍然很快，只需要根据哈希值做快速的整数比较就能<br>找到索引条目，然后一一比较返回对应的行。可以使用触发器来维护哈希值，例：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#创建表</div><div class="line">    CREATE TABLE pseudohash(</div><div class="line">        id int unsigned NOT NULL auto_increment,</div><div class="line">        url varchar(255) NOT NULL,</div><div class="line">        url_crc int unsigned NOT NULL DEFAULT 0,</div><div class="line">        PRIMARY KEY(id);</div><div class="line">    );</div><div class="line">#创建触发器</div><div class="line">    CREATE TRIGGER pseudohash_crc_ins BEFORE INSERT ON pseudohash FOR EACH ROW BEGIN</div><div class="line">    SET NEW.url_crc=CRC32(NEW.url);</div><div class="line">    END;</div><div class="line"></div><div class="line">    CREATE TRIGGER pseudohash_crc_ins BEFORE UPDATE ON pseudohash FOR EACH ROW BEGIN</div><div class="line">    SET NEW.url_crc=CRC32(NEW.url);</div><div class="line">    END;</div></pre></td></tr></table></figure>
<p> #####高性能的索引使用策略</p>
<ol>
<li><p>独立的列</p>
<blockquote>
<p>一些不恰当的查询会使MySQL无法使用已有的索引，如果查询中的列不是独立的<br>列，则MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，<br>也不能是函数的参数。例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor</div><div class="line">    <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</div></pre></td></tr></table></figure>
</blockquote>
<p>凭肉眼就能看出WHERE中的表达式其实等价于actor_id = 4，但是MySQL无法自<br>动解析这个方程式。另一个常见的错误：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> <span class="keyword">TO_DAYS</span>(<span class="keyword">CURRENT_DATE</span>)</div><div class="line">    - <span class="keyword">TO_DAYS</span>(date_col) &lt;= <span class="number">10</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>前缀索引和索引选择性</p>
<blockquote>
<p>如果索引列的字符串很长，索引会变得大且慢。通常可以索引开始部分的字符，这样可以大大节约索引<br>空间，从而提高索引效率。但这样也会降低索引的选择性。对于BLOB、TEXT或者很长的VARCHAR类型的列，<br>必须使用前缀索引，因为MySQL不允许索引这些列完整的长度。创建索引的SQL:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sakila.city_demo <span class="keyword">ADD</span> <span class="keyword">KEY</span> (city(<span class="number">7</span>));</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>多列索引</p>
<blockquote>
<p>很多人对多列索引的理解都不够，一个常见的错误就是，为每个列创建独立的索引，或者按照错误的<br>顺序创建多列索引。</p>
<ul>
<li>当出现服务器对多个索引做相交操作时(通常有多个AND条件)，通常意味着需要一个包含所有相关<br>列的多列索引，而不是多个独立的单列索引。</li>
<li>当服务器需要对多个索引做联合操作时(通常有多个OR条件)，通常需要消耗大量的CPU和内存资源<br>在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量<br>数据的时候。</li>
</ul>
</blockquote>
</li>
<li>重复索引：<br>&gt;<ol>
<li>主键列和唯一列，不需要再创建索引，因为MySQL的主键限制和唯一限制都是通过索引来实现的。</li>
<li>如果创建了索引(A,B),再创建索引(A)就是冗余索引。因为索引(A,B)也可以当作索引(A)来使用。</li>
</ol>
</li>
</ol>
<h3 id="3-EXPLAN"><a href="#3-EXPLAN" class="headerlink" title="3.EXPLAN"></a>3.EXPLAN</h3><blockquote>
<p>在MySQL中可以使用EXPLAN查看SQL执行计划，用法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>####3.1结果说明</p>
<ol>
<li>id<br><br> SELECT识别符。这是SELECT查询序列号。这个不重要。</li>
<li>select_type<br><br> 表示SELECT语句的类型，有以下几种值：<ol>
<li>SIMPLE<br><br>表示简单查询，其中不包含连接查询和子查询。</li>
<li>PRIMARY<br><br>表示主查询，或者是最外面的查询语句。</li>
<li>UNION<br><br>表示连接查询的第2个或后面的查询语句。</li>
<li>DEPENDENT UNION<br><br>UNION中的第二个或后面的SELECT语句，取决于外面的查询。</li>
<li>UNION RESULT<br>连接查询的结果</li>
<li>SUBQUERY<br>子查询中的第1个SELECT语句。</li>
<li>DEPENDENT SUBQUERY<br>子查询中的第1个SELECT语句，取决于外面的查询。</li>
<li>DERIVED<br>SELECT(FROM 子句的子查询)。</li>
</ol>
</li>
<li>type(重要)<ol>
<li>system<br><br>表仅有一行，这是const类型的特列，平时不会出现，这个也可以忽略不计。</li>
<li>const<br><br>数据表最多只有一个匹配行，因为只匹配一行数据，所以很快，常用于PRIMARY KEY或者UNIQUE<br>索引的查询，可理解为const是最优化的。</li>
<li>eq_ref<br><br>mysql手册是这样说的:”对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的<br>联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY”。eq_ref可以用于使用=比较带索引的列。</li>
<li>ref<br><br>查询条件索引既不是UNIQUE也不是PRIMARY KEY的情况。ref可用于=或&lt;或&gt;操作符的带索引的列。</li>
<li>ref_or_null<br><br>该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用<br>该联接类型的优化。<br><br><strong>上面这五种情况都是很理想的索引使用情况。</strong><br></li>
<li>index_merge<br><br>该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，<br>key_len包含了使用的索引的最长的关键元素。</li>
<li>unique_subquery<br><br>该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM<br>single_table WHERE some_expr)<br><br>unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。</li>
<li>index_subquery<br><br>该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一<br>索引: value IN (SELECT key_column FROM single_table WHERE some_expr)</li>
<li>range<br><br>只检索给定范围的行,使用一个索引来选择行。</li>
<li>index<br><br>该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。</li>
<li>ALL<br><br>对于每个来自于先前的表的行组合,进行完整的表扫描。（性能最差）</li>
</ol>
</li>
<li>table<br><br> 输出的行所引用的表。</li>
<li>possible_keys<br><br> 指出MySQL能使用哪个索引在该表中找到行。如果是空的，没有相关的索引，这时要提高性能，可<br> 通过校验WHERE子句，看是否引用某些字段，或者检查字段是不是适合索引。</li>
<li>key<br><br> 显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL。</li>
<li>key_len<br><br> 显示MySQL决定使用的键的长度。如果键是NULL，长度就是NULL。文档提示特别注意这个值可以得<br> 出一个多重主键里MySQL实际使用了哪一部分。</li>
<li>ref<br><br> 显示哪个字段或常数与key一起被使用。</li>
<li>rows<br><br> 这个数表示MySQL要遍历多少数据才能找到，在innodb上是不准确的。</li>
<li>Extra<br><br>该列包含MySQL解决查询的详细信息<ul>
<li>Distinct：MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。</li>
<li>Not exists：MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。</li>
<li>range checked for each record (index map: #)：MySQL没有发现好的可以使用的索引,<br>但发现如果来自前面的表的列值已知,可能部分索引可以<br>使用。</li>
<li>Using filesort：MySQL需要额外的一次传递,以找出如何按排序顺序检索行。</li>
<li>Using index：从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信<br>息。</li>
<li>Using temporary：为了解决查询,MySQL需要创建一个临时表来容纳结果。</li>
<li>Using where：WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。</li>
<li>Using sort_union(…), Using union(…), Using intersect(…)：这些<br>函数说明如何为index_merge联接类型合并索引扫描。</li>
<li>Using index for group-by：类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而<br>不要额外搜索硬盘访问实际的表。</li>
</ul>
</li>
</ol>
<h3 id="4-查询性能优化"><a href="#4-查询性能优化" class="headerlink" title="4.查询性能优化"></a>4.查询性能优化</h3><blockquote>
<p>查询的生命周期：从客户端，到服务器，在服务器上进行解析，生成执行计划，执行，返回结果给客户端。<br>其中”执行“可以认为是最重要的阶段。这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据<br>处理，包括排序，分组等。<br><br>查询性能低下的最基本原因是访问的数据太多。大部分性能低下的查询都可以通过减少访问的数据量的方式<br>进行优化。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效：</p>
<ol>
<li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了<br>太多的列。</li>
<li>确认MySQL服务器层是否在分析大量超过需要的数据行。</li>
</ol>
</blockquote>
<p>简单的衡量查询开销的三个指标如下：</p>
<ol>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ol>
<p>这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。</p>
<blockquote>
<ol>
<li>响应时间<br><br>响应时间分为服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间<br>是指服务器因为等待某些资源而没有真正执行查询的时间——可能是等I/O操作完成，也可能是等待行锁，<br>等待。</li>
<li>扫描的行数和返回的行数<br><br>分析查询时，查看该查询扫描的行数是非常有帮助的，这在一定程度上能够说明该查询找到需要的数据<br>的效率高不高。理想情况下扫描的行数和返回的行数应该是相同的。但实际情况这种事并不多。</li>
<li>扫描的行数和访问类型<br><br>在EXPLAIN语句中的type列反应了访问类型，访问类型有很多种，从全表扫描到索引扫描、范围扫描、<br>唯一索查询、常数引用等。这里列的这些，速度是从慢到快。扫描的行数也是从小到大。需要明白扫描<br>表，扫描索引，范围访问和单值访问的概念。</li>
</ol>
</blockquote>
<p>一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：</p>
<ol>
<li>在索引中使用WHERE条件来过滤不匹配的记录，这是在存储引擎层完成的。</li>
<li>使用索引覆盖扫描(在Extra列中出现了Using index)来返回记录，直接从索引中过滤不需要的记<br>录并返回命中的结果。这是在Mysql服务器层完成的，但无须再回表查询记录。</li>
<li>从数据表中返回数据，然后过滤不满足条件的记录(在Extra列中出现Using Where)。这在MySQL<br>服务器层完成，MySQL需要先从数据表读出记录，然后过滤。</li>
</ol>
<p>如果发现查询需要扫描大量的数据，但只返回少数的行，那么可以尝试下面的方法去优化：</p>
<ol>
<li>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返<br>回结果了。</li>
<li>改变库表结构，例如使用单独的汇总表。</li>
<li>重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。</li>
</ol>
<p>在优化有问题的查询时，目标应该是找到一个更优的方法获得实际需要的结果————而不一定总是需要从<br>MySQL获取一模一样的结果集。有时候，可以将查询转换一种写法让其返回一样的结果，但是性能更好。<br>但也可以通过修改应用代码，用另一种方式完成查询，最终达到一样的目的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-数据库范式&quot;&gt;&lt;a href=&quot;#1-数据库范式&quot; class=&quot;headerlink&quot; title=&quot;1.数据库范式&quot;&gt;&lt;/a&gt;1.数据库范式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;第一范式（1NF）：&lt;blockquote&gt;
&lt;p&gt;第一范式强调的是列的原子性，即列不能
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="http://yoursite.com/2017/07/07/first/"/>
    <id>http://yoursite.com/2017/07/07/first/</id>
    <published>2017-07-07T06:23:48.000Z</published>
    <updated>2017-07-07T07:49:02.207Z</updated>
    
    <content type="html"><![CDATA[<p>第一篇博客，欢迎大家点赞、打赏、订阅、丢香蕉给我</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一篇博客，欢迎大家点赞、打赏、订阅、丢香蕉给我&lt;/p&gt;

    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
